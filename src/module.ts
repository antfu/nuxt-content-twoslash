import type { NuxtTemplate } from '@nuxt/schema'
import type { TwoslashFloatingVueOptions } from '@shikijs/vitepress-twoslash'
import type { TwoslashOptions } from 'twoslash'
import { mkdirSync, readFileSync, writeFileSync } from 'node:fs'
import { addPlugin, addTemplate, createResolver, defineNuxtModule, normalizeTemplate } from '@nuxt/kit'
import { dirname } from 'pathe'
import { getNuxtCompilerOptions, getTypeDecorations } from './utils'

// Module options TypeScript interface definition
export interface ModuleOptions {
  /**
   * Include type decalrations generated by Nuxt (auto-imports etc.)
   *
   * @default true
   */
  includeNuxtTypes?: boolean

  /**
   * Compiler options for Twoslash
   */
  compilerOptions?: TwoslashOptions['compilerOptions']

  /**
   * Handbook options for Twoslash
   */
  handbookOptions?: TwoslashOptions['handbookOptions']

  /**
   * Options for the floating-vue renderer
   */
  floatingVueOptions?: TwoslashFloatingVueOptions

  /**
   * Enable in development mode
   *
   * @default true
   */
  enableInDev?: boolean

  /**
   * Throw errors when type error occurs
   * @default
   */
  throws?: boolean
}

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'nuxt-content-twoslash',
    configKey: 'twoslash',
  },
  // Default configuration options of the Nuxt module
  defaults: {
    includeNuxtTypes: true,
    enableInDev: true,
  },
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)
    addPlugin(resolver.resolve('./runtime/plugin'))

    const types: Record<string, string> = {}
    let compilerOptions: Record<string, any> = {}
    const path = addSyncNuxtTemplate({
      filename: 'twoslash-meta.mjs',
      getContents: () => [
        `export const rootDir = ${JSON.stringify(nuxt.options.rootDir)};`,
        `export const moduleOptions = ${JSON.stringify(options, null, 2)}`,
        `/** @type { Record<string, string> } */`,
        `export const typeDecorations = ${JSON.stringify(types, null, 2)}`,
        `/** @type { Record<string, string> } */`,
        `export const compilerOptions = ${JSON.stringify(compilerOptions, null, 2)}`,
      ].join('\n'),
    })
    nuxt.options.alias ||= {}
    nuxt.options.alias['#twoslash-meta'] = path.dst
    nuxt.options.nitro.alias ||= {}
    nuxt.options.nitro.alias['#twoslash-meta'] = path.dst

    let isHookCalled = false

    // with content v3, this runs in a Node context where `import.meta.server` is undefined
    // and #aliases don't resolve through native ESM imports
    const mdcConfigContent = readFileSync(resolver.resolve('./runtime/mdc-config.js'), 'utf-8')
    const mdcConfig = addSyncNuxtTemplate({
      filename: 'twoslash-mdc.config.mjs',
      getContents: () => mdcConfigContent,
    })

    nuxt.hook('mdc:configSources', (sources) => {
      sources.push(mdcConfig.dst)
      isHookCalled = true
    })

    if (options.includeNuxtTypes) {
      nuxt.hook('app:templatesGenerated', async () => {
        await Promise.all([
          getTypeDecorations(nuxt.options.buildDir, types),
          getNuxtCompilerOptions(nuxt.options.buildDir).then((config) => {
            compilerOptions = config
          }),
        ])
      })
    }

    nuxt.hook('app:resolve', () => {
      if (!isHookCalled && !nuxt.options._prepare)
        console.error('[nuxt-content-twoslash] TwoSlash didn\'t get initialized properly. You may need to put this module before `@nuxt/content`.')
    })
  },
})

// Write templates to disk immediately as content v3 need it when importing mdc config in node/build context
function addSyncNuxtTemplate(_template: Partial<Omit<NuxtTemplate, 'getContents'>> & { getContents: () => string }) {
  const template = normalizeTemplate({
    ..._template,
    write: true,
  })

  mkdirSync(dirname(template.dst), { recursive: true })
  writeFileSync(template.dst, _template.getContents())

  return addTemplate(template)
}
