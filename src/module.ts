import type {} from '@nuxt/schema'
import type { TwoslashFloatingVueOptions } from '@shikijs/vitepress-twoslash'
import type { TwoslashOptions } from 'twoslash'
import { addPlugin, addTemplate, createResolver, defineNuxtModule } from '@nuxt/kit'
import { getNuxtCompilerOptions, getTypeDecorations } from './utils'

// Module options TypeScript interface definition
export interface ModuleOptions {
  /**
   * Include type decalrations generated by Nuxt (auto-imports etc.)
   *
   * @default true
   */
  includeNuxtTypes?: boolean

  /**
   * Compiler options for Twoslash
   */
  compilerOptions?: TwoslashOptions['compilerOptions']

  /**
   * Handbook options for Twoslash
   */
  handbookOptions?: TwoslashOptions['handbookOptions']

  /**
   * Options for the floating-vue renderer
   */
  floatingVueOptions?: TwoslashFloatingVueOptions

  /**
   * Enable in development mode
   *
   * @default true
   */
  enableInDev?: boolean

  /**
   * Throw errors when type error occurs
   * @default
   */
  throws?: boolean
}

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'nuxt-content-twoslash',
    configKey: 'twoslash',
  },
  // Default configuration options of the Nuxt module
  defaults: {
    includeNuxtTypes: true,
    enableInDev: true,
  },
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)
    addPlugin(resolver.resolve('./runtime/plugin'))

    const types: Record<string, string> = {}
    let compilerOptions: Record<string, any> = {}

    const path = addTemplate({
      filename: 'twoslash-meta.mjs',
      write: true,
      getContents: () => {
        return [
          `export const rootDir = ${JSON.stringify(nuxt.options.rootDir)};`,
          `export const moduleOptions = ${JSON.stringify(options, null, 2)}`,
          `/** @type { Record<string, string> } */`,
          `export const typeDecorations = ${JSON.stringify(types, null, 2)}`,
          `/** @type { Record<string, string> } */`,
          `export const compilerOptions = ${JSON.stringify(compilerOptions, null, 2)}`,
        ].join('\n')
      },
    })
    nuxt.options.nitro.alias ||= {}
    nuxt.options.nitro.alias['#twoslash-meta'] = path.dst

    let isHookCalled = false

    // eslint-disable-next-line ts/ban-ts-comment
    // @ts-ignore
    nuxt.hook('mdc:configSources', async (sources: string[]) => {
      sources.push(resolver.resolve('./runtime/mdc.config'))
      isHookCalled = true
    })

    if (options.includeNuxtTypes) {
      nuxt.hook('app:templatesGenerated', async () => {
        await Promise.all([
          getTypeDecorations(nuxt.options.buildDir, types),
          getNuxtCompilerOptions(nuxt.options.buildDir).then((config) => {
            compilerOptions = config
          }),
        ])
      })
    }

    nuxt.hook('app:resolve', () => {
      if (!isHookCalled)
        console.error('[nuxt-content-twoslash] TwoSlash doesn\'t get initialized properly, you may need to put this module before `@nuxt/content`.')
    })
  },
})
